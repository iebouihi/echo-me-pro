name: Build and Push Docker Image to Docker Hub

# Trigger configuration
on:
  # Trigger on pull requests from release branches (release/*, releases/*)
  pull_request:
    branches:
      - main
      - master
  # Trigger on manual dispatch for testing
  workflow_dispatch:
    inputs:
      release_version:
        description: 'Release version for manual trigger (optional, e.g., 1.0.0)'
        required: false
        type: string



env:
  REGISTRY: docker.io
  IMAGE_NAME: iebouihi/echo-me-pro
  SCAN_SEVERITY: HIGH,CRITICAL

jobs:
  # Job 1: Validate and extract release version from PR
  extract-version:
    name: Extract Release Version
    runs-on: ubuntu-latest
    outputs:
      release-version: ${{ steps.extract.outputs.version }}
      image-tag: ${{ steps.extract.outputs.tag }}
    steps:
      # Check out the code to access release files
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      # Extract version from branch name or manual input
      - name: Extract release version from branch name
        id: extract
        run: |
          # Get version from manual input (workflow_dispatch) or extract from branch name
          if [ -n "${{ github.event.inputs.release_version }}" ]; then
            # Manual trigger with explicit version
            RELEASE_VERSION="${{ github.event.inputs.release_version }}"
            echo "âœ… Using manual input version: $RELEASE_VERSION"
          else
            # Extract from branch name (release/1.0.0 or releases/1.0.0)
            BRANCH_NAME="${{ github.head_ref }}"
            echo "ðŸ“¦ Checking branch name: $BRANCH_NAME"
            
            # Extract version from release/version or releases/version pattern
            RELEASE_VERSION=$(echo "$BRANCH_NAME" | grep -oP 'release/?s?/\K[^/]+$' || echo "")
            
            if [ -z "$RELEASE_VERSION" ]; then
              echo "âŒ ERROR: Branch must follow pattern: release/X.Y.Z or releases/X.Y.Z"
              echo "Example: release/1.0.0 or releases/1.2.3"
              exit 1
            fi
            echo "âœ… Extracted from branch: $RELEASE_VERSION"
          fi
          
          # Validate semantic versioning (supports: 1.4, 1.4.0, v1.4, v1.4.0, 1.4.0-beta)
          if ! [[ "$RELEASE_VERSION" =~ ^v?[0-9]+\.[0-9]+(\.[0-9]+)?(-[a-zA-Z0-9]+)?$ ]]; then
            echo "âŒ ERROR: Invalid version format: '$RELEASE_VERSION'"
            echo "Expected format: 1.4, 1.4.0, v1.4, v1.4.0, or 1.4.0-beta"
            exit 1
          fi
          
          # Normalize version (remove 'v' prefix if present)
          TEMP_VERSION=${RELEASE_VERSION#v}
          
          # Add patch version if missing (e.g., 1.4 â†’ 1.4.0)
          if [[ "$TEMP_VERSION" =~ ^[0-9]+\.[0-9]+$ ]]; then
            NORMALIZED_VERSION="${TEMP_VERSION}.0"
            echo "âœ… Normalized: $RELEASE_VERSION â†’ $NORMALIZED_VERSION"
          else
            NORMALIZED_VERSION=$TEMP_VERSION
            echo "âœ… Normalized: $NORMALIZED_VERSION"
          fi
          
          echo "âœ… Release version: $NORMALIZED_VERSION"
          echo "version=$NORMALIZED_VERSION" >> $GITHUB_OUTPUT
          echo "tag=iebouihi/echo-me-pro:$NORMALIZED_VERSION" >> $GITHUB_OUTPUT

  # Job 2: Build Docker image and run security scans
  build-and-scan:
    name: Build Image and Run Security Checks
    runs-on: ubuntu-latest
    needs: extract-version
    permissions:
      contents: read
      security-events: write
      packages: write
    outputs:
      image-digest: ${{ steps.build.outputs.digest }}
    steps:
      # Step 1: Checkout the repository code
      - name: Checkout code
        uses: actions/checkout@v4

      # Step 2: Set up Docker Buildx for advanced build capabilities (cross-platform, caching)
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      # Step 3: Build Docker image locally for scanning before registry push
      - name: Build Docker image for scanning
        id: build
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile
          push: false
          load: true  # Load image into Docker daemon for local scanning
          tags: ${{ needs.extract-version.outputs.image-tag }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      # Step 4: Scan image for vulnerabilities using Trivy
      # Trivy is an industry-standard scanner for container images, filesystems, and code
      - name: Run Trivy vulnerability scan
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ needs.extract-version.outputs.image-tag }}
          format: 'sarif'
          output: 'trivy-results.sarif'
          severity: ${{ env.SCAN_SEVERITY }}
          exit-code: '1'  # Fail if vulnerabilities found

      # Step 5: Upload Trivy scan results to GitHub Security tab for visibility
      - name: Upload Trivy vulnerability report to GitHub Security
        uses: github/codeql-action/upload-sarif@v3
        if: always()  # Upload even if scan fails for visibility
        with:
          sarif_file: 'trivy-results.sarif'
          category: 'trivy-scan'

      # Step 6: Run Snyk vulnerability scan for additional depth (industry-best container scanning)
      - name: Run Snyk container vulnerability scan
        uses: snyk/actions/docker@master
        env:
          SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}
        with:
          image: ${{ needs.extract-version.outputs.image-tag }}
          args: --severity-threshold=high --file=Dockerfile

      # Step 7: Scan Dockerfile best practices and security issues
      - name: Lint Dockerfile with Hadolint
        uses: hadolint/hadolint-action@v3.1.0
        with:
          dockerfile: Dockerfile
          ignore: DL3008,DL3009  # Allow unversioned package installation where needed

      # Step 8: Verify image authentication and signing capability (preparation for Step 13)
      - name: Check image architecture and metadata
        run: |
          echo "Image tag: ${{ needs.extract-version.outputs.image-tag }}"
          echo "Release version: ${{ needs.extract-version.outputs.release-version }}"
          docker image ls | grep echo-me-pro || true

  # Job 3: Push image to Docker Hub with security best practices
  push-to-registry:
    name: Push Image to Docker Hub
    runs-on: ubuntu-latest
    needs: [extract-version, build-and-scan]
    if: success()  # Only run if all previous jobs succeeded
    permissions:
      contents: read
      packages: write
    steps:
      # Step 1: Checkout code
      - name: Checkout code
        uses: actions/checkout@v4

      # Step 2: Set up Docker Buildx for efficient, cached builds
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      # Step 3: Login to Docker Hub with credentials from GitHub Secrets
      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}
        env:
          DOCKER_CONTENT_TRUST: 1  # Enable content trust for signature verification

      # Step 4: Build and push image with release version tag
      - name: Build and push Docker image to Docker Hub
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile
          push: true
          tags: |
            ${{ needs.extract-version.outputs.image-tag }}
            iebouihi/echo-me-pro:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max
          provenance: true  # Add provenance metadata for SLSA compliance
          sbom: true  # Generate Software Bill of Materials

      # Step 5: Sign image with Cosign for image authenticity
      - name: Install Cosign for image signing
        uses: sigstore/cosign-installer@v3
        with:
          cosign-release: 'v2.2.0'

      # Step 6: Sign pushed image to ensure integrity and authenticity
      - name: Sign Docker image with Cosign
        env:
          COSIGN_EXPERIMENTAL: 1  # Use OIDC token for signing
        run: |
          cosign sign --yes ${{ needs.extract-version.outputs.image-tag }}

      # Step 7: Verify image signature to confirm signing succeeded
      - name: Verify image signature
        env:
          COSIGN_EXPERIMENTAL: 1
        run: |
          cosign verify ${{ needs.extract-version.outputs.image-tag }}

  # Job 4: Post-push security validation and notifications
  post-push-validation:
    name: Validate Pushed Image
    runs-on: ubuntu-latest
    needs: [extract-version, push-to-registry]
    if: success()
    permissions:
      contents: read
    steps:
      # Step 1: Login to Docker Hub to access pushed image
      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      # Step 2: Pull and inspect pushed image for verification
      - name: Pull and inspect pushed image
        run: |
          docker pull ${{ needs.extract-version.outputs.image-tag }}
          docker inspect ${{ needs.extract-version.outputs.image-tag }}
          echo "Image successfully pushed and validated"

      # Step 3: Display summary of deployment
      - name: Display deployment summary
        run: |
          cat << EOF
          ========================================
          Docker Image Build & Push Summary
          ========================================
          Image Tag: ${{ needs.extract-version.outputs.image-tag }}
          Release Version: ${{ needs.extract-version.outputs.release-version }}
          Status: SUCCESS âœ“
          
          Next Steps:
          1. Review security scan results in GitHub Security tab
          2. Pull image: docker pull ${{ needs.extract-version.outputs.image-tag }}
          3. Run container: docker run -p 7860:7860 ${{ needs.extract-version.outputs.image-tag }}
          ========================================
          EOF

      # Step 4: Create GitHub Release (optional - uncomment if needed)
      # - name: Create GitHub Release
      #   uses: actions/create-release@v1
      #   env:
      #     GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      #   with:
      #     tag_name: v${{ needs.extract-version.outputs.release-version }}
      #     release_name: Release ${{ needs.extract-version.outputs.release-version }}
      #     body: |
      #       Docker image pushed to Docker Hub
      #       Image: ${{ needs.extract-version.outputs.image-tag }}

# Workflow-level permissions
permissions:
  contents: read
  security-events: write
